## 理解特种成员函数的生成机制

在C++官方文档中规定特种成员函数是指C++编译期会自行生成的成员函数，包括默认构造函数、析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数， 移动赋值运算符。当这些函数被使用，且类中没有显式声明这些函数的时候，编译期才会自动生成这些函数。生成的特种函数都具有public访问级别并且是inline(内联)的非虚函数。不过析构函数是例外，位于派生类中，如果基类的析构函数是虚函数，那么派生类生动生产的析构函数也是虚函数。

我们主要讨论一下啊C++11引入的移动构造函数和移动赋值运算符
```cpp
class Widget {
public:
	Widget(Widget&& rhs); // 移动构造函数
	Widget& operator=(Widget&& rhs); // 移动赋值运算符
};
```

### 1. 移动构造和移动赋值的运行过程
指的注意的是，它们执行的也是作用于非静态成员函数的“按成员移动”操作。意思是，移动构造函数将依照形参rhs的各个非静态成员函数对于本类的对应函数执行移动赋值。移动构造函数同时还会移动构造它的基类部分，移动赋值运算符则会移动赋值它的基类部分。

不过当移动操作在某个数据成员或基类部分上执行移动构造函数或移动赋值的时候，并不能保证移动操作会真的发生，英文那些不可移动的类型(包含大多数C++98中的遗留类型, 比如int，double这样的内置类型),对于这些不可移动的类型，"移动"操作实际上执行的是"复制"操作。

### 2. 拷贝与移动函数生成的区别和练习
拷贝构造函数和拷贝赋值运算符的两种操作是独立的，当声明了其中一个，并不会阻止编译器生成另一个。但是移动构造函数和移动赋值运算符不是独立的，当声明了其中一个，就会阻止编译器生成另一个。这种机制的理由在于，假设你声明了一个移动构造函数，你实际上表明移动造作的实现方式将会和编译器自动生成的按成员移动的构造函数多少有些不同，同样的，你期望的移动赋值运算符也极有可能会和自动生成的移动赋值运算符有所出入。综上，当你声明了移动构造函数或移动赋值运算符，你就需要自己实现另一个，编译器不会自动生成另一个。

一旦显示声明了拷贝操作，这个类也就不会再自动生成移动操作了。反之亦然，一旦声明了移动操作，编译器就会废除移动操作(方式为使用delete关键字删除它们)。

### 3. 大三律

如果你声明了拷贝构造函数，拷贝赋值运算符或析构函数中的任意一个，你就得同时声明所有的这三个。


大三律的思想：
如果有改写拷贝操作的需求，往往意味着执行该类需要执行某种资源管理：
- 在一种复制操作中进行任何资源管理，也极有可能在另一种复制操作中需要进行相同的资源管理。
- 该类的析构函数也会参加到该类的资源管理中。(通常是释放资源) 

这么一来，移动操作的隐式自动生成条件仅当以下三者同时成立：
- 该类未声明任何复制操作
- 该类未声明任何移动操作
- 该类未声明任何析构函数

这么一来，我们可以写一个例子, "=default"的含义是让编译器显示的自动生成代码
```cpp
class Base {
public:
	virtual ~Base() = default;
	Base(Base&&) = default;
	Base& operator=(Base&&) = default;
	Base(const Base&) = default;
	Base& operator=(const Base&) = default;
};
```

总结：C++中，特种函数的自动生成机制如下：
- 默认构造函数： 仅当类中没有显式声明任何构造函数时，编译器才会自动生成默认构造函数。
- 析构函数：自动生成的析构函数是noexcept，仅当基类中的析构函数是虚的时候，编译器才会自动生成虚析构函数。
- 拷贝运算符： 按成员进行非静态数据成员的复制。仅当类中不包含用户声明的拷贝运算符时才生成。如果该类声明了移动操作，拷贝操作将被删除。
- 移动构造函数和移动构造运算符： 都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作，移动操作，析构函数时才生成。
- 注意：成员函数模板在任何情况下都不会抑制特种函数的自动生成。